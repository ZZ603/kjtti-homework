可以用的公式

位置表示法：  

$$d = \sum_{i=1}^{n}d_{i}r^{i-1}$$

分解因式：

$$b^{n}-1 = (b-1)(b^{n-1}+b^{n-2}+……+1)$$

负数表示(二进制)：
where $k$ is the number of bits for an integer:

$$Negative(x) = 2^{k} - x$$

证明二进制的负数（two‘s complement of X）等于 X 的 ones’complement ＋ 1（即，X每位求反加1）

$$x = \sum_{i=1}^{k}d_{i}2^{i-1}$$

$\because$ 
$$Negative(x) = 2^{k} - x$$,where $k$ is the number of bits for an integer.

$\therefore$ 
$$Negative(x) = 2^{k} - 1 - x + 1$$

$\because$ 
$$b^{n}-1 = (b-1)(b^{n-1}+b^{n-2}+……+1)$$

$\therefore$ 
$$2^{k} - 1 = (2 - 1)\sum_{i=1}^{k}2^{i-1}$$,that is $k$ bits 1.

$\because$ 
$$x + \overline{x} = 1$$,where $x$ is a binary number $0$ or $1$.

$\therefore$ 
$$Negative(x) = 2^{k} - x = \sum_{i=1}^{k}2^{i-1} - x + 1 = \sum_{i=1}^{k}\overline{x_{i}} + 1$$

$\blacksquare$


关于位拓展的证明，正数显然，以下证明负数：

$\because$ Positional Notation 

$${(x)}_{2} = \sum_{i=1}^{k}d_{i}2^{i-1}$$

$\because$ Two's complement 

$$N(x) = 2^{k} - x$$, where $k$ is the number of bits for an integer and,
$$N'(x) = 2^{m} - x$$,where $$m > k$$

$\therefore$ 
$$N'(x) = 2^{m} - x = (2^{m} - 2^{k}) + 2^{k} - x = (2^{m}-1) - (2^{k}-1) + N(x)$$

$\because$ 
$$b^{n}-1 = (b-1)(b^{n-1}+b^{n-2}+……+1)$$

$\therefore$ 
$$2^{m}-1 = (2-1)\sum_{i=1}^{m}2^{i-1}$$, that is $m$ bits $1$.

So the same, 
$$(2^{k}-1)$$ is $k$ bits $1$.

$\therefore$ 
$$N'(x) = (2^{m}-1) - (2^{k}-1) + N(x) = \sum_{i=k+1}^{m}2^i + N(x) = \sum_{i=k+1}^{m}2^i + \sum_{i=1}^{k}d_{i}2^{i-1}$$

$\therefore$ If N(x) is a negative binary integer, the most-significant bit can be repeated in all the extra bits.

$\blacksquare$

证明进制转换：$r_{0}$进制转化成$r$进制

$\because$ Positional Notation

$$(d)_{r0} = \sum_{i=1}^{n}d_{i}r^{i-1}$$

$\therefore$
$$(d)_{r0} = \sum_{i=1}^{n}d_{i}r^{i-1}$$ 

$$=d_{n}r^{n-1} + d_{n-1}r^{n-2} + ··· + d_{3}r^{2} + d_{2}r + d_{1}$$ 

$$=r(d_{n}r^{n-2} +d_{n-1}r^{n-3} + ··· + d_{3}r + d_{2}) + d_{1}$$ 

$$=r(r(d_{n}r^{n-3} +d_{n-1}r^{n-4} + ··· + d_{4}r + d_{3}) + d_{2}) + d_{1}$$

$$=r(r(r(r(···(r(d_{n}) +d_{n-1}) ··· ) + d_{4}) + d_{3}) + d_{2}) + d_{1}$$

In order to get every digit , we can use Modulo operation:

$\therefore$ 

$$(d)_{r0} (mod)r = d_{1}$$ 

$\because$ 

$$\frac{(d)_{r0}}{r} 
= (d_{n}r^{n-2} +d_{n-1}r^{n-3} + ··· + d_{3}r + d_{2}) + \frac{d_{1}}{r}$$

$\therefore$ 

$$[\frac{(d)_{r0}}{r}] (mod)r = d_{2}$$

In general:

$$[\frac{(d)_{r0}}{r^{k}}] (mod)r $$ 

$$=[r(d_{n}r^{n-2-k} +d_{n-1}r^{n-3-k} + ··· + d_{k+3}r + d_{k+2}) + d_{k+1}]$$ 

$$ + \frac{d_{k}}{r} + \frac{d_{k-1}}{r^{2}} + ··· + \frac{d_{2}}{r^{k-1}} + \frac{d_{1}}{r^k}$$

It's easy to find that:

$$[\frac{(d)_{r0}}{r^{k}}] (mod)r = d_{k+1}$$


and the end is :

$$[\frac{(d)_{r0}}{r^{n-1}}] (mod)r = d_{n}$$

$\because$ when $k \ge n$

$$[\frac{(d)_{r0}}{r^{k}}] (mod)r = 0$$

So , we now get every digit and , Modulo operation is a great tool to make number base conversion.

$\blacksquare$

考虑到程序在获取每一位时是逆向进行的，即按照$d_{1}、d_{2}、···、d_{n}$的顺序，为了能让计算机从最高位输出，可以考虑用栈来实现(即先进后出的数据结构)。





模拟一下：

首先证明二进制的补码等于反码再加1

首先，
$$Negative(x) = 2^{k}-x$$，其中$k$是数字的位数（二进制）

下进行恒等变形：

$$Negative(x) = 2^{k}-x = 2^{k}-1-x+1$$

$\because$
$$b^{n}-1 = (b-1)(b^{n-1}+b^{n-2}+……+1)$$

$\therefore$
$$2^{k}-1=(2-1)(2^{k-1}+2^{k-2}+……+1)=\sum_{i=1}^{k}2^{i-1}$$这代表k个位数都是1

$\because$
$$x + \overline{x} = 1$$其中$x$是二进制数0或1

$\therefore$
$$\sum_{i=1}^{k}2^{i-1} - x = \sum_{i=1}^{k}\oveerline{x}$$

$\therefore$
$$Negative(x) = 2^{k}-x = 2^{k}-1-x+1 = \sum_{i=1}^{k}\oveerline{x} + 1$$

$\blacksquare$